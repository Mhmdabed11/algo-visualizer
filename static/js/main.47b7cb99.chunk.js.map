{"version":3,"sources":["components/ShortestPath.js","components/Node.js","algorithms/BFS.js","App.js","serviceWorker.js","index.js"],"names":["Node","React","forwardRef","ref","type","children","obstacle","typeClassName","obstacleClassName","className","cloneDeep","require","BFS","graph","start","end","newGraph","queue","animatedNodes","row","col","visited","push","queueHead","shift","getUnvisitedNeighbors","forEach","neighbor","parent","length","node","neighbors","filter","getShortestPath","currentNode","shortestPath","GraphNode","this","distance","Infinity","NUM_COLUMNS","NUM_ROWS","Graph","i","temp","j","PathFindingVisualizer","useState","setGraph","startNode","setStartNode","endNode","setEndNode","processing","setProcessing","grid","useRef","map","createRef","onClick","console","log","nodesInShortestPathOrder","reverse","setTimeout","current","classList","add","contains","remove","randomNodes","graphClone","Math","floor","random","item","subItem","el","key","path","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.47b7cb99.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./ShortestPath.css\";\r\nimport Node from \"./Node\";\r\nimport { BFS, getShortestPath } from \"../algorithms/BFS\";\r\nvar cloneDeep = require(\"lodash.clonedeep\");\r\n\r\nclass GraphNode {\r\n  constructor(row, col) {\r\n    this.row = row;\r\n    this.col = col;\r\n    this.visited = false;\r\n    this.distance = Infinity;\r\n    this.obstacle = false;\r\n  }\r\n}\r\n\r\nconst NUM_COLUMNS = 100;\r\nconst NUM_ROWS = 35;\r\n\r\nconst Graph = [];\r\nfor (let i = 0; i < NUM_ROWS; i++) {\r\n  let temp = [];\r\n  for (let j = 0; j < NUM_COLUMNS; j++) {\r\n    temp.push(new GraphNode(i, j));\r\n  }\r\n  Graph.push(temp);\r\n}\r\n\r\nexport default function PathFindingVisualizer() {\r\n  const START_ROW = 0;\r\n  const START_COL = 0;\r\n  const END_ROW = 34;\r\n  const END_COL = 99;\r\n\r\n  const [graph, setGraph] = React.useState(Graph);\r\n  const [startNode, setStartNode] = React.useState({\r\n    row: START_ROW,\r\n    col: START_COL\r\n  });\r\n  const [endNode, setEndNode] = React.useState({ row: END_ROW, col: END_COL });\r\n  const [processing, setProcessing] = React.useState(false);\r\n  const grid = React.useRef(\r\n    Graph.map(row => {\r\n      return row.map(col => {\r\n        return React.createRef();\r\n      });\r\n    })\r\n  );\r\n\r\n  // add obstacle\r\n  const addObstacle = () => {\r\n    let randomNodes = [];\r\n    const graphClone = cloneDeep(graph);\r\n    for (let i = 0; i < 300; i++) {\r\n      const row = Math.floor(Math.random() * NUM_ROWS) + 0;\r\n      const col = Math.floor(Math.random() * NUM_COLUMNS) + 0;\r\n      graphClone[row][col].obstacle = true;\r\n      randomNodes.push({ row, col });\r\n    }\r\n    randomNodes = randomNodes.filter(\r\n      node =>\r\n        !(\r\n          (node.row === startNode.row && node.col === startNode.col) ||\r\n          (node.row === endNode.row && node.col === endNode.col)\r\n        )\r\n    );\r\n    setGraph(graphClone);\r\n    return randomNodes;\r\n  };\r\n\r\n  // reset\r\n  const handleReset = () => {\r\n    if (!processing) {\r\n      setGraph(Graph);\r\n      for (let i = 0; i < Graph.length; i++) {\r\n        for (let j = 0; j < Graph[0].length; j++) {\r\n          if (grid.current[i][j].classList.contains(\"animate-node\"))\r\n            grid.current[i][j].classList.remove(\"animate-node\");\r\n          if (grid.current[i][j].classList.contains(\"animate-path\"))\r\n            grid.current[i][j].classList.remove(\"animate-path\");\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // handle find shortest path\r\n  const handleFindShortestPath = () => {\r\n    if (!processing) {\r\n      setProcessing(true);\r\n      const start = graph[START_ROW][START_COL];\r\n      const end = graph[END_ROW][END_COL];\r\n      setStartNode(start);\r\n      setEndNode(end);\r\n      console.log(BFS(graph, start, end));\r\n      const { animatedNodes, newGraph } = BFS(graph, start, end);\r\n      const nodesInShortestPathOrder = getShortestPath(\r\n        newGraph[END_ROW][END_COL]\r\n      ).reverse();\r\n\r\n      setGraph(newGraph);\r\n      for (let i = 0; i < animatedNodes.length; i++) {\r\n        if (\r\n          !(\r\n            animatedNodes[i].row === start.row &&\r\n            animatedNodes[i].col === start.col\r\n          ) &&\r\n          !(\r\n            animatedNodes[i].row === end.row && animatedNodes[i].col === end.col\r\n          )\r\n        ) {\r\n          setTimeout(\r\n            () =>\r\n              grid.current[animatedNodes[i].row][\r\n                animatedNodes[i].col\r\n              ].classList.add(\"animate-node\"),\r\n            15 * i\r\n          );\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        if (\r\n          !(\r\n            nodesInShortestPathOrder[i].row === start.row &&\r\n            nodesInShortestPathOrder[i].col === start.col\r\n          ) &&\r\n          !(\r\n            nodesInShortestPathOrder[i].row === end.row &&\r\n            nodesInShortestPathOrder[i].col === end.col\r\n          )\r\n        ) {\r\n          setTimeout(\r\n            () =>\r\n              grid.current[nodesInShortestPathOrder[i].row][\r\n                nodesInShortestPathOrder[i].col\r\n              ].classList.add(\"animate-path\"),\r\n            15 * (animatedNodes.length - 1) + 20 * i\r\n          );\r\n        }\r\n      }\r\n      setProcessing(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <button onClick={handleFindShortestPath}>Find Shortest Path</button>\r\n      <button onClick={handleReset}>Reset</button>\r\n      <button onClick={addObstacle}>Generate Walls</button>\r\n      <div className=\"grid\">\r\n        {graph.map(item => {\r\n          return item.map(subItem => {\r\n            if (\r\n              subItem.row === startNode.row &&\r\n              subItem.col === startNode.col\r\n            ) {\r\n              return (\r\n                <Node\r\n                  ref={el => (grid.current[subItem.row][subItem.col] = el)}\r\n                  key={`${subItem.row}-${subItem.col}`}\r\n                  type=\"start\"\r\n                />\r\n              );\r\n            } else if (\r\n              subItem.row === endNode.row &&\r\n              subItem.col === endNode.col\r\n            ) {\r\n              return (\r\n                <Node\r\n                  ref={el => (grid.current[subItem.row][subItem.col] = el)}\r\n                  key={`${subItem.row}-${subItem.col}`}\r\n                  type=\"finish\"\r\n                />\r\n              );\r\n            }\r\n            return (\r\n              <Node\r\n                ref={el => (grid.current[subItem.row][subItem.col] = el)}\r\n                key={`${subItem.row}-${subItem.col}`}\r\n                visited={subItem.visited}\r\n                path={subItem.path}\r\n                obstacle={subItem.obstacle}\r\n              ></Node>\r\n            );\r\n          });\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = React.forwardRef(({ type, children, obstacle }, ref) => {\r\n  let typeClassName = \"\";\r\n  let obstacleClassName = \"\";\r\n  if (type === \"start\" || type === \"finish\") {\r\n    typeClassName = `is-${type}`;\r\n  }\r\n  if (obstacle) {\r\n    obstacleClassName = \"is-obstacle\";\r\n  }\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      className={`grid-item ${typeClassName} ${obstacleClassName} `}\r\n    >\r\n      {children}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default Node;\r\n","var cloneDeep = require(\"lodash.clonedeep\");\r\n\r\nexport const BFS = (graph, start, end) => {\r\n  const newGraph = cloneDeep(graph);\r\n  let queue = [];\r\n  let animatedNodes = [];\r\n  newGraph[start.row][start.col].visited = true;\r\n  queue.push(newGraph[start.row][start.col]);\r\n  while (queue.length !== 0) {\r\n    let queueHead = queue.shift();\r\n    if (queueHead.obstacle) continue;\r\n    animatedNodes.push(queueHead);\r\n    if (queueHead.row === end.row && queueHead.col === end.col)\r\n      return { animatedNodes, newGraph };\r\n    let unvisitedNeighbors = getUnvisitedNeighbors(queueHead, newGraph);\r\n    unvisitedNeighbors.forEach(neighbor => {\r\n      if (!neighbor.visited) {\r\n        neighbor.visited = true;\r\n        neighbor.parent = queueHead;\r\n        queue.push(neighbor);\r\n      }\r\n    });\r\n  }\r\n  return { animatedNodes, newGraph };\r\n};\r\n\r\nconst getUnvisitedNeighbors = (node, graph) => {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n  if (row < graph.length - 1) neighbors.push(graph[row + 1][col]);\r\n  if (row > 0) neighbors.push(graph[row - 1][col]);\r\n  if (col < graph[0].length - 1) neighbors.push(graph[row][col + 1]);\r\n  if (col > 0) neighbors.push(graph[row][col - 1]);\r\n  neighbors = neighbors.filter(neighbor => !neighbor.visited);\r\n\r\n  return neighbors;\r\n};\r\n\r\nexport const getShortestPath = end => {\r\n  let currentNode = end;\r\n  let shortestPath = [];\r\n  while (currentNode) {\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.parent;\r\n  }\r\n  return shortestPath;\r\n};\r\n","import React from \"react\";\nimport ShortestPath from \"./components/ShortestPath\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ShortestPath />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}